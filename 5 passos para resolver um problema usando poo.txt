1. identificar as entidades que estao sendo manipuladas  (quem tem dado)
   e definir seu dominio.
preferencias
  Alcool: inteiro 
  Gasolina: inteiro 
  Diesel: inteiro

2. para cada entidade verificar quais as operacoes necessarias
preferencia
   inserirVotoGasolina()
   inserirVotoAlcool()
   inserirVotoDiesel()
   obterVotosAlcool()
   obterVotosGasolina()
   obterVotosDiesel() 
ou
   inserirVoto(TipoCombustivel)
   obterVotos(TipoCombustivel)



3. criar o prototipo da classe para cada entidade
obs: criei um enum para representar o tipo de combustivel
//enum TipoCombustivel { Alcool=0, Gasolina=1, Diesel=2 };
enum TipoCombustivel { Alcool, Gasolina, Diesel };

class preferencias
{
   private:
       int combustivel[3];
   public:
       preferencias(); //construtor, eh chamado automaticamente quando a variavel/objeto é criado.
       ~preferencias(); //destutor, eh chamada automaticamente quando a variavel sai da memoria.
       void inserirVotoGasolina();
       void inserirVotoAlcool();
       void inserirVotoDiesel();
       int obterVotosAlcool();
       int obterVotosGasolina();
       int obterVotosDiesel();
       
};

4. implementar as operacoes
preferencias::preferencias()
{
    //cout << "criou!!!!!" << endl;
    combustivel[Alcool] = combustivel[Gasolina] = combustivel[Diesel] = 0;
}

preferencias::~preferencias()
{
    //cout << "destruiu!!!!!" << endl;
}

void preferencias::inserirVotoGasolina()
{
  combustivel[Gasolina]++;
}

void preferencias::inserirVotoAlcool()
{
  combustivel[Alcool]++;
}

void preferencias::inserirVotoDiesel()
{
  combustivel[Diesel]++;
}

int preferencias::obterVotosGasolina()
{
   return combustivel[Gasolina];
}

int preferencias::obterVotosAlcool()
{
   return combustivel[Alcool];
}

int preferencias::obterVotosDiesel()
{
   return combustivel[Diesel];
}

5. fazer o programa principal

int main()
{
   preferencias pref;
   int x;
  
   cin >> x;
   while (x!=4)
   {
     switch(x)
     {
	    case 1: pref.inserirVotoAlcool();	
		break;
	    case 2: pref.inserirVotoGasolina();	
		break;
	    case 3: pref.inserirVotoDiesel();	
		break;
     } 	  
     cin >> x;
   }
   
   cout << "MUITO OBRIGADO" << endl;
   cout << "Alcool: " << pref.obterVotosAlcool() << endl;
   cout << "Gasolina: " << pref.obterVotosGasolina() << endl;
   cout << "Diesel: " << pref.obterVotosDiesel() << endl;
   
   return 0;
}




///outro exemplo
#include <iostream>
using namespace std;


//enum TipoCombustivel { Alcool=0, Gasolina=1, Diesel=2 };
enum TipoCombustivel { Alcool, Gasolina, Diesel };

//3. criar o prototipo da classe para cada entidade
class preferencias
{
   private:
       int combustivel[3];
   public:
       preferencias(); //construtor, eh chamado automaticamente quando a variavel/objeto é criado.
       ~preferencias(); //destutor, eh chamada automaticamente quando a variavel sai da memoria.
       void inserirVoto(TipoCombustivel tipo);
       int obterVotos(TipoCombustivel tipo);

};

//4. implementar as operacoes
preferencias::preferencias()
{
    //cout << "criou!!!!!" << endl;
    combustivel[Alcool] = combustivel[Gasolina] = combustivel[Diesel] = 0;
}

preferencias::~preferencias()
{
    //cout << "destruiu!!!!!" << endl;
}

void preferencias::inserirVoto(TipoCombustivel tipo)
{
  combustivel[tipo]++;
}

int preferencias::obterVotos(TipoCombustivel tipo)
{
   return combustivel[tipo];
}

//5. fazer o programa principal

int main()
{
   preferencias pref;
   int x;
  
   cin >> x;
   while (x!=4)
   {
     switch(x)
     {
	    case 1: pref.inserirVoto(Alcool);	
		break;
	    case 2: pref.inserirVoto(Gasolina);	
		break;
	    case 3: pref.inserirVoto(Diesel);	
		break;
     } 	  
     cin >> x;
   }
   
   cout << "MUITO OBRIGADO" << endl;
   cout << "Alcool: " << pref.obterVotos(Alcool) << endl;
   cout << "Gasolina: " << pref.obterVotos(Gasolina) << endl;
   cout << "Diesel: " << pref.obterVotos(Diesel) << endl;
   
   return 0;
}




///// com codigo inline
#include <iostream>
using namespace std;


//enum TipoCombustivel { Alcool=0, Gasolina=1, Diesel=2 };
enum TipoCombustivel { Alcool, Gasolina, Diesel };

//3. criar o prototipo da classe para cada entidade
class preferencias
{
   private:
       int combustivel[3];
   public:
       preferencias()                         { combustivel[Alcool] = 
                                                combustivel[Gasolina] = 
                                                combustivel[Diesel] = 0;   } //construtor, eh chamado automaticamente quando a variavel/objeto é criado.
       ~preferencias()                        {                            } //destutor, eh chamada automaticamente quando a variavel sai da memoria.
       void inserirVoto(TipoCombustivel tipo) {  combustivel[tipo]++;      }
       int obterVotos(TipoCombustivel tipo)   {  return combustivel[tipo]; }
};

//4. implementar as operacoes

//5. fazer o programa principal

int main()
{
   preferencias pref;
   int x;
  
   cin >> x;
   while (x!=4)
   {
     switch(x)
     {
	    case 1: pref.inserirVoto(Alcool);	
		break;
	    case 2: pref.inserirVoto(Gasolina);	
		break;
	    case 3: pref.inserirVoto(Diesel);	
		break;
     } 	  
     cin >> x;
   }
   
   cout << "MUITO OBRIGADO" << endl;
   cout << "Alcool: " << pref.obterVotos(Alcool) << endl;
   cout << "Gasolina: " << pref.obterVotos(Gasolina) << endl;
   cout << "Diesel: " << pref.obterVotos(Diesel) << endl;
   
   return 0;
}




problema 2057
1. entidades 
  hora
     hora, fuso

2. determinar as operacoes
    atribuirHora(hora)
    atribuirFuso(fuso)
    adicionar(horas)
    obterHora()    
    obterFuso()

3. criar as classes

class Hora 
{
   private:
      int hora, fuso;
   public:
      void atribuirHora(int h)  { hora = h;            }
      void atribuirFuso(int f)  { fuso = f;            } 
      void adicionar(int horas) { hora = hora + horas; }
      int obterFuso()		{ return fuso;         }
      int obterHora()	        { return hora;	       }
};

4. implementar operacoes

5. programa principal

int main()
{
   Hora h;
   int hora, deslocamento, fuso;
   
   cin >> hora >> deslocamento >> fuso;
   h.atribuirHorA(hora);
   h.atribuirFuso(fuso);
   h.adcionar(deslocamento);
   
   cout << h.obterHora() << endl;
   return 0;
}
   



///implementacao completa em c++
#include <iostream>
using namespace std;

class Hora 
{
   private:
      int hora, fuso;
   public:
      void atribuirHora(int h)  { hora = h;            }
      void atribuirFuso(int f)  { fuso = f;            } 
      void adicionar(int horas);
      int obterFuso()	    	{ return fuso;         }
      int obterHora()           { return hora;         } 
      int obterHoraLocal();
};

//adicionar serve para alterar a hora, incrementando x horas
void Hora::adicionar(int horas) 
{ 
    if (hora+horas<0) // caso a hora seja negativa, tem que voltar a 24 horas
        hora = 24 + hora+horas;
    else  // % 24, forca a nao ultrapassar 24 horas, ou seja, 25 vai virar 1.
        hora = (hora + horas) % 24; 
}

//obter hora local serve para retornar o valor da hora 0-23, considerando o fuso
int Hora::obterHoraLocal()
{
   if (hora+fuso<0)
     return 24 + (hora+fuso);
   else
     return (hora + fuso) % 24;
}

int main()
{
   Hora h;
   int hora, deslocamento, fuso;
   
   cin >> hora >> deslocamento >> fuso;
   h.atribuirHora(hora);
   h.atribuirFuso(fuso);
   h.adicionar(deslocamento);
   
   cout << h.obterHoraLocal() << endl;
   return 0;
}

